var redis = require('../services/redis-client')()
    ,when = require('when')
    ,pipeline = require('when/pipeline')
    ,nodefn = require('when/node/function')
    ,_ = require('lodash')
    ,crypto = require('crypto')
    ;

var getRedis = nodefn.lift(redis.get.bind(redis))
    ,delRedis = nodefn.lift(redis.del.bind(redis))
    ,hsetRedis = nodefn.lift(redis.hset.bind(redis))
    ,hgetRedis = nodefn.lift(redis.hget.bind(redis))
    ,hdelRedis = nodefn.lift(redis.hdel.bind(redis))
    ,hkeysRedis = nodefn.lift(redis.hkeys.bind(redis))
    ;

var mixins = {
    
    /**
     * Clear the cache
     * @param  {Mixed} what Identifier to denote what keys to clear. `true` alone removes all keys. `true` and other args will be used to match a specific hash generated by those arguments. Otherwise a RegExp or function will be used to test against keys and remove those that match.
     * @return {Promise}
     */
    clear: function( what ){

        var self = this
            ,args
            ,hash
            ;

        if (!what){
            return when(false);
        }

        if ( what === true ){

            if ( arguments.length === 1 ){

                // clear all from redis
                return delRedis( self.hashScope ).yield( true );

            } else {

                args = Array.prototype.slice.call( arguments, 1 );
                hash = self.hashFn.apply( self.scope, args );
                // clear just the hash that matches
                hdelRedis( self.hashScope, hash ).yield( 1 );
            }

            return self;
        }

        if (what instanceof RegExp){

            what = _.wrap(what, function(reg, val){
                return reg.test(val);
            });
        }

        if (typeof what === 'function'){

            return hkeysRedis( self.hashScope ).then(function( keys ){

                var toRm = _.filter( keys, what, self.scope );
                if (!toRm.length){
                    return 0;
                }

                toRm.unshift( self.hashScope );

                return hdelRedis( toRm ).yield( toRm.length );
            });
        }

        return when(false);
    },

    // clear cache on first call
    fresh: function(){

        // clear all
        this.clear( true );

        return this;
    }
};


function createCacheFunction( cfg ){

    var fn = function ( _args_ ){

        var scope = fn.scope
            ,args = Array.prototype.slice.call( arguments )
            ,hash = fn.hashFn.apply( scope, args )
            ,hashScope = fn.hashScope
            ;

        return hgetRedis( hashScope, hash ).then(function(result){

            // if there's a cached result...
            if (result){
                // return the cached copy
                // console.log('cached copy of', hashScope, hash)
                return JSON.parse( result );
            }

            // console.log('fresh copy of', hashScope, hash)
                    
            // apply the action
            return when(fn.action.apply( scope, args ))
                .then(function( val ){

                    var result = JSON.stringify( val );

                    // store in redis
                    redis.hset( hashScope, hash, result || 'false' );

                    // with expire if applicable
                    if ( fn.lifetime ){
                        redis.expire( hashScope, fn.lifetime );
                    }

                    return val;
                })
                ;
        });
    };

    var shasum = crypto.createHash('sha1');
    shasum.update(cfg.action.toString() + cfg.hashFn.call(cfg.scope));

    _.extend(fn, mixins, cfg, {
        hashScope: shasum.digest('hex')
    });

    return fn;
}

/**
 * Build a function that caches its result
 * @param  {Function} action   The function called to get the cacheable value. Must accept a callback, or return a Promise. eg: function( arg1, arg2, ..., done ){ ... done(err, result); }
 * @param  {Function|String} hashFn   (optional) The unique hash to use to cache the value, or function to dynamically build that value. default is to use the function arguments passed.
 * @param  {Number} lifetime (optional) The time in seconds to keep the value in cache.
 * @param  {Object} scope (optional) the scope to execute methods in
 * @return {Function}          The wrapped function that will return a Promise.
 */
function cache ( action, hashFn, lifetime, scope ){

    if ( typeof action === 'object' ){

        return cache( action.action, action.hashFn, action.lifetime, action.scope );
    }

    // validate and fix arguments...
    if ( !scope ){

        if (!lifetime && typeof hashFn === 'object' ){

            scope = hashFn;
            hashFn = undefined;

        } else if ( typeof lifetime === 'object' ){

            scope = lifetime;
            lifetime = undefined;

        } else {

            scope = null;
        }
    }

    if ( !lifetime && typeof hashFn === 'number' ){

        lifetime = hashFn;
        hashFn = undefined;

    } else {

        lifetime = 60 * 60 * 24 * 7 * 4; // 28 days if not specified
    }

    if ( lifetime && typeof lifetime !== 'number' ){
        
        throw "lifetime value must be a number";
    }

    if ( typeof hashFn !== 'function' ){

        if ( hashFn === undefined ){
            
            // build hash using arguments
            hashFn = function(){ 
                return 'args:' + JSON.stringify(Array.prototype.slice.call( arguments ));
            };

        } else if ( typeof hashFn === 'string' && hashFn.length ){

            // static string hash
            hashFn = _.wrap(hashFn, function( hash ){
                return hash;
            });

        } else {

            throw 'Value of hashFn must be a function or string.';
        }
    }

    return createCacheFunction({
        action: action,
        lifetime: lifetime,
        hashFn: hashFn,
        scope: scope
    });
}

module.exports = cache;
